/*
 * 
 * Copyright  1990-2007 Sun Microsystems, Inc. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version
 * 2 only, as published by the Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 2 for more details (a copy is
 * included at /legal/license.txt).
 * 
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
 * Clara, CA 95054 or visit www.sun.com if you need additional
 * information or have any questions.
 */

package com.sun.mmedia;
import  javax.microedition.media.*;
import  javax.microedition.media.control.*;
import  javax.microedition.media.protocol.SourceStream;
import  java.util.Enumeration;
import  java.util.Hashtable;
import  java.util.Vector;
import  com.sun.j2me.app.AppPackage;
import  com.sun.mmedia.PlayerStateSubscriber;


// #ifndef ABB [
import javax.microedition.media.protocol.DataSource;
// #endif ]
import java.io.IOException;

public class PlayerImpl implements Player {

    // #ifdef ENABLE_DEBUG [
    private final static boolean debug = true;
    // #else ][
    private final static boolean debug = false;
    // #endif ]

    public PlayerStateSubscriber state_subscriber = null;

    protected BasicPlayer playerInst = null;
    public    BasicPlayer getPlayerInst(){ return playerInst; };
    
    protected DataSource  source;
    protected SourceStream stream;
    private boolean isClosed = false;

    private String  mediaFormat = null;
    private boolean handledByDevice = false;
    private boolean handledByJava = false;
    private int hNative;      // handle of native API library 


    private int loopCount = 0; /* if set in unrealized state */
    private Vector listeners = new Vector(2);

    /**
     * hastable to map playerID to instances
     */
    private static Hashtable mplayers = new Hashtable(4);
    /**
     * table of player states
     */
    private static Hashtable pstates = new Hashtable();
    /**
     * table of media times
     */
    private static Hashtable mtimes = new Hashtable();

    /**
     * VM paused?
     */
    private static boolean vmPaused = false;

    /**
     * global player id
     */
    private static int pcount = -1;
    /**
     * player ID of this player
     */
    protected int pID = 0;
    /**
     * lock object
     */
    private static Object idLock = new Object();


    // Init native library
    protected native int nInit(int appId, int pID, String URI);
    // Terminate native library
    protected native int nTerm(int handle);
    // Get Media Format
    protected native String nGetMediaFormat(int handle);
    // Need media Download in Java side?
    protected native boolean nIsHandledByDevice(int handle);

    // Realize native player
    protected native boolean nRealize(int handle, String mime);
    // get java buffer size to determine media format
    protected static native int nGetJavaBufferSize(int handle);
    // get first packet size to determine media format
    protected static native int nGetFirstPacketSize(int handle);
    // buffering media data
    protected static native int nBuffering(int handle, byte[] buffer, int size);
    // ask Native Player if it needs more data immediatelly
    protected static native boolean nNeedMoreDataImmediatelly(int hNative);    
    // Provide whole media content size, if known
    protected static native void nSetWholeContentSize(int hNative, long contentSize);

    private static String PL_ERR_SH = "Cannot create a Player: ";
    
    /**
     * Constructor 
     */
    private PlayerImpl() {};

    public PlayerImpl(DataSource source) throws MediaException, IOException {
        // Get current application ID to support MVM
        int appId = AppPackage.getInstance().getId();

        synchronized (idLock) {
            pcount = (pcount + 1) % 32767;
            pID = pcount;
        }

        String locator = source.getLocator();
        hNative = nInit(appId, pID, locator);

        if (0 == hNative) {
            throw new MediaException("Unable to create native player");
        } else if (-1 == hNative) {
            throw new IOException("Unable to create native player");
        }

        mediaFormat     = nGetMediaFormat(hNative);
        if (mediaFormat.equals(BasicPlayer.MEDIA_FORMAT_UNSUPPORTED)) {
            /* verify if handled by Java */
            mediaFormat = Configuration.getConfiguration().ext2Format(source.getLocator());
            if (mediaFormat == null || mediaFormat.equals(BasicPlayer.MEDIA_FORMAT_UNSUPPORTED)) {
                nTerm(hNative);
                throw new MediaException("Unsupported Media Format:" + mediaFormat + " for " + source.getLocator());
            } else {
                handledByJava = true;
            }
        }

        if (locator != null && mediaFormat.equals(BasicPlayer.MEDIA_FORMAT_UNKNOWN)) {
            if (locator.equals(Manager.TONE_DEVICE_LOCATOR)) {
                mediaFormat = BasicPlayer.MEDIA_FORMAT_DEVICE_TONE;
                handledByDevice = true;
            } else if (locator.equals(Manager.MIDI_DEVICE_LOCATOR)) {
                mediaFormat = BasicPlayer.MEDIA_FORMAT_DEVICE_MIDI;
                handledByDevice = true;
            }
        } else if (locator != null && locator.startsWith(Configuration.CAPTURE_LOCATOR)) {
            if (locator.startsWith(Configuration.AUDIO_CAPTURE_LOCATOR)) {
                mediaFormat = BasicPlayer.MEDIA_FORMAT_CAPTURE_AUDIO;
            } else if (locator.startsWith(Configuration.VIDEO_CAPTURE_LOCATOR)) {
                mediaFormat = BasicPlayer.MEDIA_FORMAT_CAPTURE_VIDEO;
            } else if (locator.startsWith(Configuration.RADIO_CAPTURE_LOCATOR)) {
                mediaFormat = BasicPlayer.MEDIA_FORMAT_CAPTURE_RADIO;
            }
            handledByDevice = true;
        }

        if (!handledByJava && !handledByDevice) {
            handledByDevice = nIsHandledByDevice(hNative);
        }

        this.source = source;

        if (!handledByDevice) {
            source.connect();
            stream = source.getStreams()[0];
        }
    }

        
/* JAVADOC ELIDED */
    public void realize() throws MediaException {
        if (playerInst != null) {
            if (isClosed) {
                throw new IllegalStateException();
            }
            return;
        }
        String type = source.getContentType();
        if (type == null && stream != null && stream.getContentDescriptor() != null) {
            type = stream.getContentDescriptor().getContentType();
        }
        /* try to realize native player */
        if (!nRealize(hNative, type)) {
            throw new MediaException("Can not realize");
        }

        if (!handledByDevice && !handledByJava) {
            mediaFormat = nGetMediaFormat(hNative);
            if (mediaFormat.equals(BasicPlayer.MEDIA_FORMAT_UNSUPPORTED)) {
                String format;
                /* verify if handled by Java */
                if (type != null &&
                        (format = Configuration.getConfiguration().mime2Format(type)) != null && 
                        !format.equals(BasicPlayer.MEDIA_FORMAT_UNKNOWN) && 
                        !format.equals(BasicPlayer.MEDIA_FORMAT_UNSUPPORTED)) {
                    mediaFormat = format;
                    handledByJava = true;
                } else {
                    throw new MediaException("Unsupported media format");
                }
            }
            /* predownload media data to recognize media format and/or 
               specific media parameters (e.g. duration) */
            if (!mediaFormat.equals(BasicPlayer.MEDIA_FORMAT_TONE)) {
                doBuffering(hNative, stream);
            }
        }

        if (mediaFormat.equals(BasicPlayer.MEDIA_FORMAT_UNKNOWN)) {        
            /* ask media format if unknown */
            mediaFormat = nGetMediaFormat(hNative);

            if (mediaFormat.equals(BasicPlayer.MEDIA_FORMAT_UNKNOWN)) {
                throw new MediaException("Unknown Media Format");
            }
            if (mediaFormat.equals(BasicPlayer.MEDIA_FORMAT_UNSUPPORTED)) {
                throw new MediaException("Unsupported Media Format");
            }
        }

        /* create Implementation Player */
        playerInst = getPlayerFromType(mediaFormat);

        playerInst.notificationSource = this;
        playerInst.hNative            = hNative;
        playerInst.mediaFormat        = mediaFormat;
        playerInst.handledByDevice    = handledByDevice;
        playerInst.pID                = pID;

        playerInst.setSource(source);

        if (loopCount != 0) {
            playerInst.setLoopCount(loopCount);
        }
        if (listeners.size() > 0) {
            for(int i=0; i<listeners.size(); i++)
                playerInst.addPlayerListener((PlayerListener)listeners.elementAt(i));
            listeners.removeAllElements();
        }
        mplayers.put(new Integer(pID), playerInst);

        playerInst.realize();
        if (null != state_subscriber) {
            state_subscriber.PlayerRealized(this);
        }
    };

    /**
     *  Buffering portion of media data
     *
     * @param  hNative             Descriptor of native player
     * @param  stream              Source stream
     *
     * @exception  MediaException     read from Source Stream error
     */
    static void doBuffering(int hNative, SourceStream stream) 
        throws MediaException {

        long contLength = stream.getContentLength();
        boolean need_more = true;

        if (contLength > 0) {
            nSetWholeContentSize(hNative, contLength);
        }
        /* first loop - allocate java buffer*/
        int javaBufSize = nGetJavaBufferSize(hNative);
        int packetSize  = nGetFirstPacketSize(hNative);
        if (packetSize > 0) {
            if (javaBufSize <= 0) {
                javaBufSize = 1024;
            }

            byte[] buffer;
            try {
                buffer = new byte[(int)javaBufSize];
            } catch(OutOfMemoryError ome) {
                throw new MediaException("Not enough memory");
            }

            do {
                int num_read = 0;
                int ret;
                if (packetSize > javaBufSize) {
                    packetSize = javaBufSize;
                }
                do {
                    try {
                        // read from source stream
                        ret = stream.read(buffer, num_read, packetSize - num_read);
                    } catch(IOException e) {
                        throw new MediaException("Read from source error");
                    }
                    if (ret > 0) {
                        num_read += ret;
                    }
                    if (ret == -1) {
                        need_more = false;
                        break;
                    }
                } while(num_read < packetSize);
                if (num_read > 0) {
                    packetSize = nBuffering(hNative, buffer, num_read);
                    if (packetSize >=0) {
                        need_more = nNeedMoreDataImmediatelly(hNative);
                    } else {
                        throw new MediaException("Buffering media data error");
                    }
                }
            } while (need_more);
        }
    };

    /**
     *  Gets the playerFromType attribute of the Manager class
     *
     * @param  type                Description of the Parameter
     * @return                     The playerFromType value
     * @exception  IOException     Description of the Exception
     * @exception  MediaException  Description of the Exception
     */
    private BasicPlayer getPlayerFromType(String type) throws MediaException {
        String className;

        className = Configuration.getConfiguration().getHandler(type);
        if (className == null) {
            if (DirectPlayer.nIsVideoControlSupported(hNative)) {
                className = "com.sun.mmedia.DirectVideo";
            } else if (DirectPlayer.nIsToneControlSupported(hNative)) {
                className = "com.sun.mmedia.DirectTone";
            } else if (DirectPlayer.nIsMIDIControlSupported(hNative)) {
                className = "com.sun.mmedia.DirectMIDI";
            } else {
                className = "com.sun.mmedia.DirectPlayer";
            }              
        }

        if ((type == null) || className == null) {
            throw new MediaException(PL_ERR_SH + "MediaFormat " + type + " is not supported");
        }

        BasicPlayer p = null;

        if (debug)
            System.out.println("getPlayerFromType " + className);

        try {
            // ... try and instantiate the handler ...
            Class handlerClass = Class.forName(className);
            p = (BasicPlayer) handlerClass.newInstance();
        } catch (Exception e) {
            if (debug)
                System.out.println("Class not found " + className);
            throw new MediaException(PL_ERR_SH + e.getMessage());
        }
        return p;
    }

/* JAVADOC ELIDED */
    public void prefetch() throws MediaException {
        if (isClosed) {
            throw new IllegalStateException();
        }
        if (playerInst == null) {
            realize();
        }
        if (playerInst != null) {
            playerInst.chkClosed(false);

            if (vmPaused) {
                if (debug)
                    System.out.println("ERROR: Try to prefetch player during paused state");
                return;
            }        

            playerInst.prefetch();

            if (null != state_subscriber) {
                state_subscriber.PlayerPrefetched(this);
            }
        }
    };

/* JAVADOC ELIDED */
    public void start() throws MediaException {
        if (isClosed) {
            throw new IllegalStateException();
        }
        if (playerInst == null) {
            realize();
        }
        if ( getState() == REALIZED )
        {
            prefetch();
        }
        if (playerInst != null) {
            playerInst.chkClosed(false);

            if (vmPaused) {
                if (debug)
                    System.out.println("ERROR: Try to start player during paused state");
                return;
            }
            playerInst.start();
        }
    };

/* JAVADOC ELIDED */
    public void stop() throws MediaException {
        if (isClosed) {
            throw new IllegalStateException();
        }
        if (playerInst != null) {
            playerInst.stop();
        }
    }

/* JAVADOC ELIDED */
    public void deallocate() {
        if (playerInst != null) {
            playerInst.deallocate();
            if( null != state_subscriber && 
                ( getState() == PREFETCHED || getState() == STARTED ) ) {
                state_subscriber.PlayerDeallocated(this);
            }
        } else {
            // Player in the UNREALIZED or CLOSED state
            if (isClosed) {
                throw new IllegalStateException();
            }
        }
    };

/* JAVADOC ELIDED */
    public void close() {
        if (playerInst != null) {
            playerInst.close();
            mplayers.remove(new Integer(pID));
        } else {
            if (!isClosed) {
                /* close source of unrealized player */
                if (source != null) {
                    source.disconnect();
                    source = null;
                }
                /* close native part of unrealized player */
                if(hNative != 0) {
                    nTerm(hNative);
                }
            }
        }
        isClosed = true;
    }
    
    // #ifndef ABB [
    /**
     * Sets the <code>TimeBase</code> for this <code>Player</code>.
     * <p>
     * A <code>Player</code> has a default <code>TimeBase</code> that
     * is determined by the implementation. 
     * To reset a <code>Player</code> to its default 
     * <code>TimeBase</code>, call <code>setTimeBase(null)</code>.
     *
     * @param master The new <CODE>TimeBase</CODE> or 
     * <CODE>null</CODE> to reset the <code>Player</code>
     * to its default <code>TimeBase</code>.
     * @exception IllegalStateException Thrown if the <code>Player</code>
     * is in the <i>UNREALIZED</i>, <i>STARTED</i> or <i>CLOSED</i> state.
     * @exception MediaException Thrown if
     * the specified <code>TimeBase</code> cannot be set on the 
     * <code>Player</code>.
     * @see #getTimeBase
     */
    public void setTimeBase(TimeBase master) throws MediaException {
        if (playerInst != null) {
            playerInst.setTimeBase(master);
        } else {
            // Player in the UNREALIZED or CLOSED state
            throw new IllegalStateException();
        }
    };
    // #endif ]

    // #ifndef ABB [
    /**
     * Gets the <code>TimeBase</code> that this <code>Player</code> is using.
     * @return The <code>TimeBase</code> that this <code>Player</code> is using.
     * @see #setTimeBase
     *
     * @exception IllegalStateException Thrown if the <code>Player</code>
     * is in the <i>UNREALIZED</i> or <i>CLOSED</i> state.
     */
    public TimeBase getTimeBase() {
        if (playerInst != null) {
            return playerInst.getTimeBase();
        }
        // Player in the UNREALIZED or CLOSED state
        throw new IllegalStateException();
    };
    // #endif ]

    /**
     * Sets the <code>Player</code>'s&nbsp;<i>media time</i>.
     * <p>
     * For some media types, setting the media time may not be very
     * accurate.  The returned value will indicate the 
     * actual media time set.
     * <p>
     * Setting the media time to negative values will effectively
     * set the media time to zero.  Setting the media time to
     * beyond the duration of the media will set the time to
     * the end of media.
     * <p>
     * There are some media types that cannot support the setting
     * of media time.  Calling <code>setMediaTime</code> will throw
     * a <code>MediaException</code> in those cases.
     * 
     * @param now The new media time in microseconds.
     * @return The actual media time set in microseconds.
     * @exception IllegalStateException Thrown if the <code>Player</code>
     * is in the <i>UNREALIZED</i> or <i>CLOSED</i> state.
     * @exception MediaException Thrown if the media time
     * cannot be set.
     * @see #getMediaTime
     */
    public long setMediaTime(long now) throws MediaException {
        if (isClosed) {
            throw new IllegalStateException();
        }
        if (playerInst != null) {
            return playerInst.setMediaTime(now);
        }
        throw new IllegalStateException();
    };

/* JAVADOC ELIDED */
    public long getMediaTime() {
        if (isClosed) {
            throw new IllegalStateException();
        }
        if (playerInst != null) {
            return playerInst.getMediaTime();
        } else {
            return Player.TIME_UNKNOWN;
        }
    };

    /**
     * Gets the current state of this <code>Player</code>.
     * The possible states are: <i>UNREALIZED</i>,
     * <i>REALIZED</i>, <i>PREFETCHED</i>, <i>STARTED</i>, <i>CLOSED</i>.
     * 
     * @return The <code>Player</code>'s current state.
     */
    public int getState() {
        if (playerInst != null) {
            return playerInst.getState();
        }
        return isClosed ? Player.CLOSED : Player.UNREALIZED;
    };

    /**
     * Get the duration of the media.
     * The value returned is the media's duration
     * when played at the default rate.
     * <br>
     * If the duration cannot be determined (for example, the
     * <code>Player</code> is presenting live
     * media)  <CODE>getDuration</CODE> returns <CODE>TIME_UNKNOWN</CODE>.
     *
     * @return The duration in microseconds or <code>TIME_UNKNOWN</code>.
     * @exception IllegalStateException Thrown if the <code>Player</code>
     * is in the <i>CLOSED</i> state.
     */
    public long getDuration() {
        if (isClosed) {
            throw new IllegalStateException();
        }
        if (playerInst != null) {
            return playerInst.getDuration();
        } else {
            return Player.TIME_UNKNOWN;
        }
    };

    /**
     * Get the content type of the media that's
     * being played back by this <code>Player</code>.
     * <p>
     * See <a href="Manager.html#content-type">content type</a>
     * for the syntax of the content type returned.
     *
     * @return The content type being played back by this 
     * <code>Player</code>.
     * @exception IllegalStateException Thrown if the <code>Player</code>
     * is in the <i>UNREALIZED</i> or <i>CLOSED</i> state.
     */
    public String getContentType() {
        if (playerInst != null) {
            return playerInst.getContentType();
        }
        throw new IllegalStateException();
    };


/* JAVADOC ELIDED */

    public void setLoopCount(int count) {
        if (isClosed) {
            throw new IllegalStateException();
        }
        if (playerInst != null) {
            playerInst.setLoopCount(count);
        } else {
            if (count != 0) {
                loopCount = count;
            } else {
                throw new IllegalArgumentException();
            }
        }
    };

/* JAVADOC ELIDED */
    public void addPlayerListener(PlayerListener playerListener) {
        if (isClosed) {
            throw new IllegalStateException();
        }
        if (playerInst != null) {
            playerInst.addPlayerListener(playerListener);
        } else {
            if (playerListener != null) {
                listeners.addElement(playerListener);
            }
        }
    };

/* JAVADOC ELIDED */
    public void removePlayerListener(PlayerListener playerListener) {
        if (isClosed) {
            throw new IllegalStateException();
        }
        if (playerInst != null) {
            playerInst.removePlayerListener(playerListener);
        } else {
            listeners.removeElement(playerListener);
        }
    };

    /**
     *  Gets the controls attribute of the BasicPlayer object
     *
     * @return    The controls value
     */
    public final Control[] getControls() {
        if (playerInst != null) {
            return playerInst.getControls();
        }
        throw new IllegalStateException();
    }


    /**
     * Gets the <code>Control</code> that supports the specified
     * class or interface. The full class
     * or interface name should be specified.
     * <code>Null</code> is returned if the <code>Control</code>
     * is not supported.
     *
     * @param  type  Description of the Parameter
     * @return       <code>Control</code> for the class or interface
     * name.
     */
    public Control getControl(String type) {
        if (playerInst != null) {
            return playerInst.getControl(type);
        }
        throw new IllegalStateException();
    }

    /**
     * For global PlayerID management
     *
     * @param  pid  Description of the Parameter
     * @return      Description of the Return Value
     */
    public static BasicPlayer get(int pid) {
        return (BasicPlayer) (mplayers.get(new Integer(pid)));
    }

    /**
     * Send external volume changed event to all of the player from this VM
     */
    public static void sendExternalVolumeChanged(String evt, int volume) {
        if (mplayers == null) {
            return;
        }

        /* Send event to player if this player is in realized state (or above) */
        for (Enumeration e = mplayers.elements(); e.hasMoreElements();) {
            BasicPlayer p = (BasicPlayer) e.nextElement();
            int state = p.getState();
            if (state >= Player.REALIZED) {
                if (debug) System.out.println("Send [" + evt + "] to Player " + p.toString());
                VolumeControl vc = (VolumeControl)p.getControl("VolumeControl");
                if (vc != null) {
                    vc.setLevel(volume);
                }
            }
        }
    }

    /**
     *  Pauses and deallocates all media players.
     *
     *  After this call all players are either in realized
     *  or unrealized state.  
     *
     *  Resources are being released during deallocation.
     */
    public static void pauseAll() {
        vmPaused = true;
    
        if (mplayers == null) {
            return;
        }

        for (Enumeration e = mplayers.elements(); e.hasMoreElements();) {
            BasicPlayer p = (BasicPlayer) e.nextElement();

            int state = p.getState();
            long time = p.getMediaTime();
            
            // save the player's state
            pstates.put(p, new Integer(state));
            // save the player's media time
            mtimes.put(p, new Long(time));

            try {
                // Stop the player
                if (state == Player.STARTED) {
                    p.stop();
                }
            } catch(MediaException ex) {
            }
            if (debug) 
                System.out.println("*** pause MMAPI : " + p + "(" + state + ") ***");
        }
    }


    /**
     *  Resumes all media players' activities.
     *
     *  Players that were in STARTED state when pause
     *  was called will resume playing at the media time
     *  they were stopped and deallocated.
     */
    public static void resumeAll() {
        vmPaused = false;
        
        if (mplayers == null || pstates.size() == 0) {
            return;
        }
        
        for (Enumeration e = mplayers.elements(); e.hasMoreElements();) {
            BasicPlayer p = (BasicPlayer) e.nextElement();

            int state = ((Integer) pstates.get(p)).intValue();
            long time = ((Long) mtimes.get(p)).longValue();

            if (debug)
                System.out.println("MMAPI resumeAll state: " + state);

            switch (state) {
                /*
                case Player.PREFETCHED:
                    try {
                        p.prefetch();
                        p.setMediaTime(time);
                    } catch (MediaException ex) {
                    }
                    break;
                */
                case Player.STARTED:
                    try {
                        //p.realize();
                        //p.prefetch();
                        if (p.getState() != Player.STARTED) {
                            p.setMediaTime(time);
                            p.start();
                        }
                    } catch (MediaException ex) {
                    }
                    break;
            }
        }

        // clear player states and media times
        pstates.clear();
        mtimes.clear();
    }

}
